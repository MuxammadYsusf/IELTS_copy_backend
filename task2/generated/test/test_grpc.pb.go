// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.1
// source: test/test.proto

package test

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	QuestionService_CreateQuestion_FullMethodName           = "/test.QuestionService/CreateQuestion"
	QuestionService_GetQuestion_FullMethodName              = "/test.QuestionService/GetQuestion"
	QuestionService_GetAllQuestions_FullMethodName          = "/test.QuestionService/GetAllQuestions"
	QuestionService_UpdateQuestion_FullMethodName           = "/test.QuestionService/UpdateQuestion"
	QuestionService_DeleteQuestion_FullMethodName           = "/test.QuestionService/DeleteQuestion"
	QuestionService_AnswerToQuestions_FullMethodName        = "/test.QuestionService/AnswerToQuestions"
	QuestionService_SaveResult_FullMethodName               = "/test.QuestionService/SaveResult"
	QuestionService_GetResulByAttempt_FullMethodName        = "/test.QuestionService/GetResulByAttempt"
	QuestionService_GetAttemptList_FullMethodName           = "/test.QuestionService/GetAttemptList"
	QuestionService_GetUsersAnswerForAttempt_FullMethodName = "/test.QuestionService/GetUsersAnswerForAttempt"
	QuestionService_GetUserHistory_FullMethodName           = "/test.QuestionService/GetUserHistory"
	QuestionService_CheckAttemptsExist_FullMethodName       = "/test.QuestionService/CheckAttemptsExist"
	QuestionService_GetLastestAttempt_FullMethodName        = "/test.QuestionService/GetLastestAttempt"
	QuestionService_SaveAttempts_FullMethodName             = "/test.QuestionService/SaveAttempts"
	QuestionService_CheckAnswers_FullMethodName             = "/test.QuestionService/CheckAnswers"
)

// QuestionServiceClient is the client API for QuestionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuestionServiceClient interface {
	CreateQuestion(ctx context.Context, in *CreateQuestionRequest, opts ...grpc.CallOption) (*CreateQuestionResponse, error)
	GetQuestion(ctx context.Context, in *GetQuestionRequest, opts ...grpc.CallOption) (*GetQuestionResponse, error)
	GetAllQuestions(ctx context.Context, in *GetAllQuestionsRequest, opts ...grpc.CallOption) (*GetAllQuestionsResponse, error)
	UpdateQuestion(ctx context.Context, in *UpdateQuestionRequest, opts ...grpc.CallOption) (*UpdateQuestionResponse, error)
	DeleteQuestion(ctx context.Context, in *DeleteQuestionRequest, opts ...grpc.CallOption) (*DeleteQuestionResponse, error)
	AnswerToQuestions(ctx context.Context, in *AnswerToQuestionsRequest, opts ...grpc.CallOption) (*AnswerToQuestionsResponse, error)
	SaveResult(ctx context.Context, in *SaveResultRequest, opts ...grpc.CallOption) (*SaveResultResponse, error)
	GetResulByAttempt(ctx context.Context, in *GetResultByAttemptRequest, opts ...grpc.CallOption) (*GetResultByAttemptResponse, error)
	GetAttemptList(ctx context.Context, in *GetAttemptListRequest, opts ...grpc.CallOption) (*GetAttemptListResponse, error)
	GetUsersAnswerForAttempt(ctx context.Context, in *GetUsersAnswerForAttemptRequest, opts ...grpc.CallOption) (*GetUsersAnswerForAttemptResponse, error)
	GetUserHistory(ctx context.Context, in *GetUserHistoryRequest, opts ...grpc.CallOption) (*GetUserHistoryResponse, error)
	CheckAttemptsExist(ctx context.Context, in *CheckAttemptsExistRequest, opts ...grpc.CallOption) (*CheckAttemptsExistResponce, error)
	GetLastestAttempt(ctx context.Context, in *GetLastestAttemptRequest, opts ...grpc.CallOption) (*GetLastestAttemptResponse, error)
	SaveAttempts(ctx context.Context, in *SaveAttemptsRequest, opts ...grpc.CallOption) (*SaveAttemptsResponse, error)
	CheckAnswers(ctx context.Context, in *CheckAnswersRequest, opts ...grpc.CallOption) (*CheckAnswersResponse, error)
}

type questionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQuestionServiceClient(cc grpc.ClientConnInterface) QuestionServiceClient {
	return &questionServiceClient{cc}
}

func (c *questionServiceClient) CreateQuestion(ctx context.Context, in *CreateQuestionRequest, opts ...grpc.CallOption) (*CreateQuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateQuestionResponse)
	err := c.cc.Invoke(ctx, QuestionService_CreateQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetQuestion(ctx context.Context, in *GetQuestionRequest, opts ...grpc.CallOption) (*GetQuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetAllQuestions(ctx context.Context, in *GetAllQuestionsRequest, opts ...grpc.CallOption) (*GetAllQuestionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllQuestionsResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetAllQuestions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) UpdateQuestion(ctx context.Context, in *UpdateQuestionRequest, opts ...grpc.CallOption) (*UpdateQuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateQuestionResponse)
	err := c.cc.Invoke(ctx, QuestionService_UpdateQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) DeleteQuestion(ctx context.Context, in *DeleteQuestionRequest, opts ...grpc.CallOption) (*DeleteQuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteQuestionResponse)
	err := c.cc.Invoke(ctx, QuestionService_DeleteQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) AnswerToQuestions(ctx context.Context, in *AnswerToQuestionsRequest, opts ...grpc.CallOption) (*AnswerToQuestionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnswerToQuestionsResponse)
	err := c.cc.Invoke(ctx, QuestionService_AnswerToQuestions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) SaveResult(ctx context.Context, in *SaveResultRequest, opts ...grpc.CallOption) (*SaveResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveResultResponse)
	err := c.cc.Invoke(ctx, QuestionService_SaveResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetResulByAttempt(ctx context.Context, in *GetResultByAttemptRequest, opts ...grpc.CallOption) (*GetResultByAttemptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResultByAttemptResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetResulByAttempt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetAttemptList(ctx context.Context, in *GetAttemptListRequest, opts ...grpc.CallOption) (*GetAttemptListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAttemptListResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetAttemptList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetUsersAnswerForAttempt(ctx context.Context, in *GetUsersAnswerForAttemptRequest, opts ...grpc.CallOption) (*GetUsersAnswerForAttemptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsersAnswerForAttemptResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetUsersAnswerForAttempt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetUserHistory(ctx context.Context, in *GetUserHistoryRequest, opts ...grpc.CallOption) (*GetUserHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserHistoryResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetUserHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) CheckAttemptsExist(ctx context.Context, in *CheckAttemptsExistRequest, opts ...grpc.CallOption) (*CheckAttemptsExistResponce, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckAttemptsExistResponce)
	err := c.cc.Invoke(ctx, QuestionService_CheckAttemptsExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetLastestAttempt(ctx context.Context, in *GetLastestAttemptRequest, opts ...grpc.CallOption) (*GetLastestAttemptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLastestAttemptResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetLastestAttempt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) SaveAttempts(ctx context.Context, in *SaveAttemptsRequest, opts ...grpc.CallOption) (*SaveAttemptsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveAttemptsResponse)
	err := c.cc.Invoke(ctx, QuestionService_SaveAttempts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) CheckAnswers(ctx context.Context, in *CheckAnswersRequest, opts ...grpc.CallOption) (*CheckAnswersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckAnswersResponse)
	err := c.cc.Invoke(ctx, QuestionService_CheckAnswers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuestionServiceServer is the server API for QuestionService service.
// All implementations must embed UnimplementedQuestionServiceServer
// for forward compatibility.
type QuestionServiceServer interface {
	CreateQuestion(context.Context, *CreateQuestionRequest) (*CreateQuestionResponse, error)
	GetQuestion(context.Context, *GetQuestionRequest) (*GetQuestionResponse, error)
	GetAllQuestions(context.Context, *GetAllQuestionsRequest) (*GetAllQuestionsResponse, error)
	UpdateQuestion(context.Context, *UpdateQuestionRequest) (*UpdateQuestionResponse, error)
	DeleteQuestion(context.Context, *DeleteQuestionRequest) (*DeleteQuestionResponse, error)
	AnswerToQuestions(context.Context, *AnswerToQuestionsRequest) (*AnswerToQuestionsResponse, error)
	SaveResult(context.Context, *SaveResultRequest) (*SaveResultResponse, error)
	GetResulByAttempt(context.Context, *GetResultByAttemptRequest) (*GetResultByAttemptResponse, error)
	GetAttemptList(context.Context, *GetAttemptListRequest) (*GetAttemptListResponse, error)
	GetUsersAnswerForAttempt(context.Context, *GetUsersAnswerForAttemptRequest) (*GetUsersAnswerForAttemptResponse, error)
	GetUserHistory(context.Context, *GetUserHistoryRequest) (*GetUserHistoryResponse, error)
	CheckAttemptsExist(context.Context, *CheckAttemptsExistRequest) (*CheckAttemptsExistResponce, error)
	GetLastestAttempt(context.Context, *GetLastestAttemptRequest) (*GetLastestAttemptResponse, error)
	SaveAttempts(context.Context, *SaveAttemptsRequest) (*SaveAttemptsResponse, error)
	CheckAnswers(context.Context, *CheckAnswersRequest) (*CheckAnswersResponse, error)
	mustEmbedUnimplementedQuestionServiceServer()
}

// UnimplementedQuestionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQuestionServiceServer struct{}

func (UnimplementedQuestionServiceServer) CreateQuestion(context.Context, *CreateQuestionRequest) (*CreateQuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) GetQuestion(context.Context, *GetQuestionRequest) (*GetQuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) GetAllQuestions(context.Context, *GetAllQuestionsRequest) (*GetAllQuestionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllQuestions not implemented")
}
func (UnimplementedQuestionServiceServer) UpdateQuestion(context.Context, *UpdateQuestionRequest) (*UpdateQuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) DeleteQuestion(context.Context, *DeleteQuestionRequest) (*DeleteQuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) AnswerToQuestions(context.Context, *AnswerToQuestionsRequest) (*AnswerToQuestionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnswerToQuestions not implemented")
}
func (UnimplementedQuestionServiceServer) SaveResult(context.Context, *SaveResultRequest) (*SaveResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveResult not implemented")
}
func (UnimplementedQuestionServiceServer) GetResulByAttempt(context.Context, *GetResultByAttemptRequest) (*GetResultByAttemptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResulByAttempt not implemented")
}
func (UnimplementedQuestionServiceServer) GetAttemptList(context.Context, *GetAttemptListRequest) (*GetAttemptListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAttemptList not implemented")
}
func (UnimplementedQuestionServiceServer) GetUsersAnswerForAttempt(context.Context, *GetUsersAnswerForAttemptRequest) (*GetUsersAnswerForAttemptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsersAnswerForAttempt not implemented")
}
func (UnimplementedQuestionServiceServer) GetUserHistory(context.Context, *GetUserHistoryRequest) (*GetUserHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserHistory not implemented")
}
func (UnimplementedQuestionServiceServer) CheckAttemptsExist(context.Context, *CheckAttemptsExistRequest) (*CheckAttemptsExistResponce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAttemptsExist not implemented")
}
func (UnimplementedQuestionServiceServer) GetLastestAttempt(context.Context, *GetLastestAttemptRequest) (*GetLastestAttemptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastestAttempt not implemented")
}
func (UnimplementedQuestionServiceServer) SaveAttempts(context.Context, *SaveAttemptsRequest) (*SaveAttemptsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveAttempts not implemented")
}
func (UnimplementedQuestionServiceServer) CheckAnswers(context.Context, *CheckAnswersRequest) (*CheckAnswersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAnswers not implemented")
}
func (UnimplementedQuestionServiceServer) mustEmbedUnimplementedQuestionServiceServer() {}
func (UnimplementedQuestionServiceServer) testEmbeddedByValue()                         {}

// UnsafeQuestionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuestionServiceServer will
// result in compilation errors.
type UnsafeQuestionServiceServer interface {
	mustEmbedUnimplementedQuestionServiceServer()
}

func RegisterQuestionServiceServer(s grpc.ServiceRegistrar, srv QuestionServiceServer) {
	// If the following call pancis, it indicates UnimplementedQuestionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QuestionService_ServiceDesc, srv)
}

func _QuestionService_CreateQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).CreateQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_CreateQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).CreateQuestion(ctx, req.(*CreateQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetQuestion(ctx, req.(*GetQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetAllQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllQuestionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetAllQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetAllQuestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetAllQuestions(ctx, req.(*GetAllQuestionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_UpdateQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).UpdateQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_UpdateQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).UpdateQuestion(ctx, req.(*UpdateQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_DeleteQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).DeleteQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_DeleteQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).DeleteQuestion(ctx, req.(*DeleteQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_AnswerToQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnswerToQuestionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).AnswerToQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_AnswerToQuestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).AnswerToQuestions(ctx, req.(*AnswerToQuestionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_SaveResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).SaveResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_SaveResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).SaveResult(ctx, req.(*SaveResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetResulByAttempt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResultByAttemptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetResulByAttempt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetResulByAttempt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetResulByAttempt(ctx, req.(*GetResultByAttemptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetAttemptList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttemptListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetAttemptList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetAttemptList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetAttemptList(ctx, req.(*GetAttemptListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetUsersAnswerForAttempt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsersAnswerForAttemptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetUsersAnswerForAttempt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetUsersAnswerForAttempt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetUsersAnswerForAttempt(ctx, req.(*GetUsersAnswerForAttemptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetUserHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetUserHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetUserHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetUserHistory(ctx, req.(*GetUserHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_CheckAttemptsExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAttemptsExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).CheckAttemptsExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_CheckAttemptsExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).CheckAttemptsExist(ctx, req.(*CheckAttemptsExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetLastestAttempt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastestAttemptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetLastestAttempt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetLastestAttempt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetLastestAttempt(ctx, req.(*GetLastestAttemptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_SaveAttempts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveAttemptsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).SaveAttempts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_SaveAttempts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).SaveAttempts(ctx, req.(*SaveAttemptsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_CheckAnswers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAnswersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).CheckAnswers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_CheckAnswers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).CheckAnswers(ctx, req.(*CheckAnswersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QuestionService_ServiceDesc is the grpc.ServiceDesc for QuestionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QuestionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.QuestionService",
	HandlerType: (*QuestionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateQuestion",
			Handler:    _QuestionService_CreateQuestion_Handler,
		},
		{
			MethodName: "GetQuestion",
			Handler:    _QuestionService_GetQuestion_Handler,
		},
		{
			MethodName: "GetAllQuestions",
			Handler:    _QuestionService_GetAllQuestions_Handler,
		},
		{
			MethodName: "UpdateQuestion",
			Handler:    _QuestionService_UpdateQuestion_Handler,
		},
		{
			MethodName: "DeleteQuestion",
			Handler:    _QuestionService_DeleteQuestion_Handler,
		},
		{
			MethodName: "AnswerToQuestions",
			Handler:    _QuestionService_AnswerToQuestions_Handler,
		},
		{
			MethodName: "SaveResult",
			Handler:    _QuestionService_SaveResult_Handler,
		},
		{
			MethodName: "GetResulByAttempt",
			Handler:    _QuestionService_GetResulByAttempt_Handler,
		},
		{
			MethodName: "GetAttemptList",
			Handler:    _QuestionService_GetAttemptList_Handler,
		},
		{
			MethodName: "GetUsersAnswerForAttempt",
			Handler:    _QuestionService_GetUsersAnswerForAttempt_Handler,
		},
		{
			MethodName: "GetUserHistory",
			Handler:    _QuestionService_GetUserHistory_Handler,
		},
		{
			MethodName: "CheckAttemptsExist",
			Handler:    _QuestionService_CheckAttemptsExist_Handler,
		},
		{
			MethodName: "GetLastestAttempt",
			Handler:    _QuestionService_GetLastestAttempt_Handler,
		},
		{
			MethodName: "SaveAttempts",
			Handler:    _QuestionService_SaveAttempts_Handler,
		},
		{
			MethodName: "CheckAnswers",
			Handler:    _QuestionService_CheckAnswers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "test/test.proto",
}
